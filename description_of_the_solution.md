  Формулировка задачи:
"В качестве тестового задания решите проектную задачу в условиях независимых тестов. Длительность тестов можно считать целочисленной, 
а ограничение на суммарное время - не слишком большим.

Вход программы: N пар чисел (по количеству тестов) и ограничение на суммарное время работы. 
                В каждой паре одно число - предполагаемая длительность теста, второе - предполагаемая вероятность его падения.
Выход программы: набор тестов, для которого вероятность обнаружить ошибку в коде максимальна, 
                 а суммарное время работы не превышает ограничение; вероятность обнаружения ошибки в коде для данного набора тестов.

Напомним, что обнаружение ошибки в коде соответствует падению хотя бы одного теста из запускаемого набора.
Реализовывать решение следует на языке Go."

  Решение:
Для решения данной задачи применялись принципы динамического программирования,
а именно данное решение схоже с решением задачи о рюкзаке без повторений.
Вместо предметов были тесты, вес предметов заменился на длительность каждого теста,
а стоимость - на вероятность падения.

В обычной задаче о рюкзаке в качестве решения подзадачи мы выбирали максимум
из двух значение: стоимость рюкзака, если мы возьмем текущий предмет и стоимость - если брать
его не будем.

Если бы мы для решения подзадачи выбирали максимум из двух вероятностей:
вероятности падения набора тестов, если мы будем запускать текущий тест,
и вероятности падения, если запускать его не будем, то для подсчета одной из вероятностей, 
нам нужно было бы воспользоваться формулой включений-исключений.
Технически эффективнее найти набор тестов, для которых вероятность успешного выполнения минимальна.

Обозначим через $mtx[t, j]$ - минимальную вероятность успеха, если можно запускать тесты 1..j
(1 <= j <= N, N - количество всех тестов), общая длительность не превышает значения T, а t = 0..T.
Тогда задача: найти mtx[T, N].

Заполним все элементы mtx любыми значениями от 2.0 и больше.
В данной динамике есть три перехода:
  первый случай, когда мы не будем брать текущий тест, тогда
  mtx[t, j] выражается как min(mtx[t][j - 1], mtx[t][j]);
  
  второй случай, когда решение для предыдущего времени t - 1 оказалось лучше,
  чем для текущего, тогда
  mtx[t][j] = min(mtx[t][j], mtx[t - 1][j]);

  третий случай, когда мы добавляем текущий тест в искомый набор тестов и 
  mtx[t][j] = min(mtx[t][j], mtx[t - t_j][j - 1] * (1 - p_j));
  где t_j - длительности j-го теста, а p_j - вероятность его падения.

Для улучшения точности ответа вместо 1 - p_j будем использовать ln(1 - p_j),
тогда mtx[t][j] = min(mtx[t][j], mtx[t - t_j][j - 1] + ln(1 - p_j));

---------------------IO_of_the_solution---------------------------------------------

Считывание данных происходит из консоли по следующему шаблону:
int int
int double
int double
......

где первые два int-а соответствуют максимальной продолжительности и количеству тестов соответственно,
а дальше идут пары: целочисленная продолжительность теста и вещественная вероятность его падения.
Пример входных данных в консоли:
10 6
1 0.01
2 0.25
3 0.25
4 0.125
5 0.25
6 0.1
Решение выводится так же в консоль.
Пример выходных данных для указанных входных данных:
The set of tests:
2 3 5 
The probability:
0.5781249999385136
